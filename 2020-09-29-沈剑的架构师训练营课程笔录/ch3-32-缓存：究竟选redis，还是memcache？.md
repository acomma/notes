## 32、缓存：究竟选redis，还是memcache？

互联网分层架构，最常用的 KV 缓存是：

（1）redis

（2）memcache

选型时，到底选 redis 还是 mc？

memcache 和 redis 是互联网分层架构中最常见的 kv 缓存，不少同学在选型的时候会纠结到底是选 redis 还是 memcache。虽然 redis 比 memcache 更晚出来，且功能确实更丰富一些，但对于一个技术人来说了解所以然恐怕比选择谁更重要一些。

### 什么时候倾向于选择 redis？

什么时候更倾向于选择 redis 呢？业务需求决定技术选型。当业务有这样一些特点的时候选择 redis 可能更合适一些。

（1）复杂数据结构

第一，复杂的数据结构。当 kv 中的 value 是哈希，列表，集合，有序集合这类复杂的数据结构时，必须要选择 redis。因为 mc 无法满足这些需求。最典型的业务场景比如：用户订单列表，用户消息列表，帖子评论列表等等。此时复杂的数据结构应该选择 redis。

（2）持久化

第二点，持久化。mc 无法满足持久化的需求，此时 redis 是更好的选择。但这里我想要提醒的是，我们的业务场景中真的需要依赖 redis 的持久化功能吗？千万不要把 redis 当数据库使用。redis 的定期快照并不能保证数据不丢失，redis 的 aof 会降低效率并且不能支持太大的数据量。不要期望 redis 的固化存储会比 MySQL 做的更好，不同的工具有各自擅长的事情，把 redis 当数据库用，八成设计是有问题的。

缓存场景开启固化功能有什么利弊呢？如果知识简单的缓存，应该把数据存放在数据库，缓存在 redis。此时开启固化功能，优点是 redis 挂了再重启，内存能够快速的恢复热数据，不会瞬间的将压力压到数据库上，不需要一个 cache 的预热过程。但它的不足是在 redis 挂了的过程中，如果数据库中有数据修改可能导致 redis 重启之后，数据库与 redis 的数据不一致，因为 redis 恢复的是之前固化的数据。因此只读场景或者允许一些不一致的业务场景（例如：计数）可以尝试 redis 的固化功能，其他场景，原则上不应该依赖于 redis 的固化。

（3）天然高可用

情况三，当需要天然支持集群高可用时，redis 是更好的选择。redis 天然支持集群功能，可以实现主从复制，读写分离。redis 官方也提供了 sentinel 的集群管理工具，能够实现主从服务的监控，故障自动转移。这一切对于客户端都是透明的，无需程序改动，也无需人工介入。而 mc 如果想要实现高可用需要进行二次开发，例如客户端的双读双写或者服务端的集群同步。但这里想要提醒的是绝大部分的业务场景，缓存真的需要高可用吗？缓存挂了，如果不出现雪崩，缓存挂了，很多时候是允许 cache miss 的，此时可以通过 db 读取数据。所以我们需要认真的剖析业务场景是否对缓存有高可用的需求。

（4）存储内容比较大

第四种情况，当存储的内容比较大时更加适合使用 redis。mc 的 kv 存储 value 最大为 1M，如果存储的 value 比较大，我们只能使用 redis。

以上四个场景，更倾向于使用 redis，因为 mc 并不能满足相关的业务需求。

### 什么时候倾向于选择 memcache？

**纯 KV，数据量，并发量大时。**

当业务为纯 KV，存储 key 的数量非常大并且并发也相对较大时，使用 mc 或许更加适合。这是为什么呢？这还要从 mc 与 redis 的底层实现机制的差异说起。

（1）内存分配

在内存分配上，mc 使用预分配内存池的方式管理内存，他能够省去内存的分配时间并且没有碎片。而 redis 则是临时申请空间，可能导致内存碎片。从这一点上说 mc 会比 redis 更快一些。

（2）虚拟内存使用

第二点，虚拟内存的使用。mc 会把所有的数据存储在物理内存里。redis 有自己的 vm 机制，理论上能够存储比物理内存更多的数据量，当数据量超过物理内存时，会引发 swap 把冷数据刷到磁盘上。从这一点来说数据量大时，mc 也会更快一些。但最新版的 redis 里，升级了 vm 机制，毕竟这个机制会导致频繁的刷盘，性能会极大的降低。

（3）网络模型

第三点，网络模型。mc 使用的是非阻塞的 io 复用模型，redis 也使用的是非阻塞的 io 复用模型，但由于 redis 还提供了一些非 kv 存储之外的排序呀，聚合呀，复杂数据结构啊等额外的功能，在执行这些功能时有复杂的 cpu 计算，有可能阻塞整个 io 调度。从这一点上来说，由于 redis 提供的功能较多，mc 会更快一些。

（4）线程模型

第四点，线程模型的差异。mc 使用多线程，主线程监听，worker 子线程接受请求执行读写。而 redis 使用单线程模型，虽然没有锁冲突，但难以利用多核的特性提升整体的吞吐量。所以从这一点上说在多核的情况下 mc 可能会更快一些。

### 关于 redis 和 mc，最后还有两点想说的

（1）源代码可读性

第一点是代码的可读性。我看过 mc 和 redis 的代码，从可读性上来说，redis 是我见过代码最清爽的软件，甚至没有之一。编译 redis 甚至不需要 configure，也不依赖于第三方库，一个 make 就搞定了。而 mc 可能考虑了太多的扩展性于多系统的兼容性，代码并不是特别清爽，看起来有点费劲。例如网络 io 的部分，redis 源码一到两个文件就搞定了，mc 使用了 libevent，一个 fd（句柄）传过来传过去，又 pipe，又（跨）线程的，容易把人搞晕。理论上 mc 只支持 kv，而 redis 支持了那么多的功能，mc 的性能应该高非常非常的多，但实际并非如此，真的有可能是代码质量相关的问题。

（2）水平扩展性

第二点水平扩展性。不管是 mc 和 redis 服务集群没有天然的支持水平扩展，需要在客户端进行分片，其实这对调用方来说并不是特别友好。如果能够在服务端集群支持水平扩展，这两种缓存都会更完美一些。

### 总结

**什么时候选 redis？**

（1）复杂数据结构

（2）持久化

（3）天然高可用

（4）存储内容比较大

**什么时候选择 memcache？**

纯 KV

**为什么 mc 在纯 KV 能更快呢？**

（1）预分配内存池

（2）redis 的 VM 机制更慢

（3）redis 的 CPU 计算复杂

（4）多线程可利用多核

**其他：**

（1）redis 源码可读性好

（2）redis 和 mc 都需要手动水平切分
